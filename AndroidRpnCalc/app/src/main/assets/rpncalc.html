<!DOCTYPE html>
<html lang='en'>
<head>
  <title>RPNCalc</title>
  <meta charset="utf-8">
  <meta name='HandheldFriendly' content='true' />
  <meta name='viewport' content='width=device-width,height=device-height,user-scalable=no' />


<script type="text/javascript">

// Order matters. Number keys are progressively unhidden.
const BASES = {
   BIN: 0,
   OCT: 1,
   DEC: 2,
   HEX: 3,
}

const PREC = {
   ALL: 0, // Actually rounded.
   FIX: 1, // Does not do true fixed-point arithmetic.
   SCI: 2,
}

const MODES = {
   DEG: 0,
   RAD: 1,
}

const MIN_BITWISE_VAL = -Math.pow(2, 31)
const BLINK_DELAY_MS = 480
// Round values to avoid long strings of 9's or 0's.
// e.g.  30 sin -> 0.499999... should be 0.5
// e.g. sqrt(8) * sqrt(8) -> 7.999999... should be 8
// e.g. asin 0.5 -> 30.00000000000001 should be 30
const ROUND_LIM = 1e13
// 'e' exponent 2.4e3
// 'E' hex value 0xE
// Fortunately, we never have to display Euler's constant, e = 2.17
const EXPO_CHR = 'e'
// In Javascript, rounding starts at 15 to 17 decimal places.
const MAX_PRECISION = 16

var STACK
var SAVED_STACK
var PENDING
var IS_LEFT_SHIFTED
var IS_RIGHT_SHIFTED
var DISP_PREC
var STORED_X
var BASE
var PRECISION
var MODE
var MODE_CONV
var BLINK_STATE
var IS_BLINKING


document.onkeyup = kbd
window.onresize = resizeButtonHeight

function _resetCalc() {
    STACK = []
    SAVED_STACK = []
    PENDING = ''
    IS_LEFT_SHIFTED = false
    IS_RIGHT_SHIFTED = false
    DISP_PREC = 4
    STORED_X = null
    BASE = BASES.DEC
    PRECISION = PREC.ALL
    MODE = MODES.DEG
    MODE_CONV = (MODE == MODES.DEG ? (Math.PI / 180.0) : 1.0)
    BLINK_STATE = false
    IS_BLINKING = false
    _enableBaseKeys()
    _updateLcd()
}

function init() {
    _resetCalc()
    _updateLcd()
    resizeButtonHeight()
// This is a very simple test framework.
// This file gets injected into rpmcalc.html and is automatically run.
// FIXME Add more tests for number validation, radian calculations, error conditions.
// This only tests functionality; it does not test hiding numbers when base changes.
// For keyboard, only keys are tested, not every function.

let TEST_RESULTS = []
let TEST_COUNTER = 0
let CURRENT_TEST = ''

// Test harness functions.
function it(name, fn) {
    TEST_COUNTER++
    CURRENT_TEST = TEST_COUNTER+'. '+name
    TEST_RESULTS.push(CURRENT_TEST)
    console.log(CURRENT_TEST)
    resetCalc()
    fn()
}

function show_test_results(txt) {
    _stopBlinking()
    console.log(txt)
    setTimeout(() => {
        const lcdEle = gId('lcd')
        lcdEle.value = txt
        lcdEle.scrollTop = lcdEle.scrollHeight
    }, BLINK_DELAY_MS * 2) // '*2' ensures blinking has stopped.
}

function all_tests_passed() {
    show_test_results('\nAll '+TEST_COUNTER+' tests have passed.')
}

function fail(errmsg) {
    show_test_results([CURRENT_TEST, errmsg, 'Test failed'].join('\n'))
    throw new Error(errmsg)
}

function expect(val) {
  return {
      toEqual: (exp) => { if (val.toString() != exp.toString()) { fail('Actual: '+val+'\nExpected: '+exp) }},
      toBeTruthy: () => { if (!val) { fail('Expected '+val+' to be truthy.') }},
      toBeFalsy: () => { if (val) { fail('Expected '+val+' to be falsy.') }},
  }
}


// Helper functions
function gId(id) {
  return document.getElementById(id)
}
function getLcd() {
  return gId('lcd').value
}
function getLeftShiftInd() {
  return gId('lsind').innerHTML
}
function getRightShiftInd() {
  return gId('rsind').innerHTML
}
function getBaseInd() {
  return gId('baseind').innerText
}
function getPrecisionInd() {
  return gId('precind').innerText
}
function getModeInd() {
  return gId('modeind').innerText
}
function getStoreInd() {
  return gId('stoind').innerText
}

function resetCalc() {
  _resetCalc()
  _updateLcd()
}

function getBlinkOnChar() {
  return '\u25fb'
}

function getBlinkOffChar() {
  return '\u25fc'
}

function getLeftShiftIndChar() {
  return '\u21b0'
}

function getRightShiftIndChar() {
  return '\u21b1'
}

function toLcd(val) {
  let lines = []
  if (Array.isArray(val)) {
      lines = val
  } else {
      lines.push(val)
  }
  while (lines.length < 5) {
      lines.unshift('')
  }
  return lines.join('\n')
}

function isBlinking() {
  let lcd = getLcd()
  const lastChr = lcd.substring(lcd.length-1)
  return (lastChr == getBlinkOnChar() || lastChr == getBlinkOffChar())
}

function getNonBlinkingText() {
  let lcd = getLcd()
  return lcd.substring(0, lcd.length-1)
}

// Stack with pending entry
function expectPending(val) {
  expect(isBlinking()).toBeTruthy()
  expect(getNonBlinkingText()).toEqual(toLcd(val))
}

// Stack with no entry pending
function expectStack(val) {
    expect(isBlinking()).toBeFalsy()
    expect(getLcd()).toEqual(toLcd(val))
}

function btnRcl() { btnLeftShift();  btnSto() }
function btnMode() { btnLeftShift();  btnBase() }
function btnRootxy() { btnLeftShift();  btnSqrt() }
function btnAsin() { btnLeftShift();  btnSin() }
function btnAcos() { btnLeftShift();  btnCos() }
function btnAtan() { btnLeftShift();  btnTan() }
function btnPowex() { btnLeftShift();  btnRecip() }
function btnPow10x() { btnLeftShift();  btnPowyx() }
function btnRand() { btnLeftShift();  btnChangeSign() }
function btnCombo() { btnLeftShift();  btnExpo() }

function btnAnd() { btnRightShift(); btnSto() }
function btnNot() { btnRightShift(); btnDisp() }
function btnOr() { btnRightShift(); btnBase() }
function btnXor() { btnRightShift(); btnSqrt() }
function btnUndo() { btnRightShift(); btnSwap() }
function btnLn() { btnRightShift(); btnRecip() }
function btnLog() { btnRightShift(); btnPowyx() }
function btnMod() { btnRightShift(); btnChangeSign() }
function btnFact() { btnRightShift(); btnExpo() }
function btnClear() { btnRightShift(); btnDeleteChar() }

function btnHexA() { btnRightShift(); btn0() }
function btnHexB() { btnRightShift(); btn1() }
function btnHexC() { btnRightShift(); btn2() }
function btnHexD() { btnRightShift(); btn3() }
function btnHexE() { btnRightShift(); btn4() }
function btnHexF() { btnRightShift(); btn5() }


function btnTau() { btnLeftShift(); btnDot() }
function btnPi() { btnRightShift(); btnDot() }

// Tests
it('leftshift: should toggle indicator', () => {
  expect(getLeftShiftInd()).toEqual('')
  btnLeftShift()
  expect(getLeftShiftInd()).toEqual(getLeftShiftIndChar())
  btnLeftShift()
  expect(getLeftShiftInd()).toEqual('')
})

it('leftshift: should cancel right shift', () => {
  expect(getRightShiftInd()).toEqual('')
  btnRightShift()
  expect(getRightShiftInd()).toEqual(getRightShiftIndChar())
  btnLeftShift()
  expect(getRightShiftInd()).toEqual('')
})

it('rightshift: should toggle indicator', () => {
  expect(getRightShiftInd()).toEqual('')
  btnRightShift()
  expect(getRightShiftInd()).toEqual(getRightShiftIndChar())
  btnRightShift()
  expect(getRightShiftInd()).toEqual('')
})

it('rightshift: should cancel left shift', () => {
  expect(getLeftShiftInd()).toEqual('')
  btnLeftShift()
  expect(getLeftShiftInd()).toEqual(getLeftShiftIndChar())
  btnRightShift()
  expect(getLeftShiftInd()).toEqual('')
})





it('0: should show', () => {
  btn0()
  expectPending(0)
  btnEnter()
  expectStack(0)
})

it('leftshift_0: should do nothing', () => {
  btnLeftShift()
  btn0()
  expectStack('')
})

it('rightshift_0: should do nothing', () => {
  btnRightShift()
  btn0()
  expectStack('')
})

it('1: should show', () => {
  btn1()
  expectPending(1)
  btnEnter()
  expectStack(1)
})

it('leftshift_1: should do nothing', () => {
  btnLeftShift()
  btn1()
  expectStack('')
})

it('rightshift_1: should do nothing', () => {
  btnRightShift()
  btn1()
  expectStack('')
})



it('2: should show', () => {
  btn2()
  expectPending(2)
  btnEnter()
  expectStack(2)
})

it('leftshift_2: should do nothing', () => {
  btnLeftShift()
  btn2()
  expectStack('')
})

it('rightshift_2: should do nothing', () => {
  btnRightShift()
  btn2()
  expectStack('')
})



it('should 3', () => {
  btn3()
  expectPending(3)
  btnEnter()
  expectStack(3)
})

it('leftshift_3: should do nothing', () => {
  btnLeftShift()
  btn3()
  expectStack('')
})

it('rightshift_3: should do nothing', () => {
  btnRightShift()
  btn3()
  expectStack('')
})



it('should 4', () => {
  btn4()
  expectPending(4)
  btnEnter()
  expectStack(4)
})

it('leftshift_4: should do nothing', () => {
  btnLeftShift()
  btn4()
  expectStack('')
})

it('rightshift_4: should do nothing', () => {
  btnRightShift()
  btn4()
  expectStack('')
})


it('5: should show', () => {
  btn5()
  expectPending(5)
  btnEnter()
  expectStack(5)
})

it('leftshift_5: should do nothing', () => {
  btnLeftShift()
  btn5()
  expectStack('')
})

it('rightshift_5: should do nothing', () => {
  btnRightShift()
  btn5()
  expectStack('')
})


it('6: should show', () => {
  btn6()
  expectPending(6)
  btnEnter()
  expectStack(6)
})

it('leftshift_6: should do nothing', () => {
  btnLeftShift()
  btn6()
  expectStack('')
})

it('rightshift_6: should do nothing', () => {
  btnRightShift()
  btn6()
  expectStack('')
})


it('7: should show', () => {
  btn7()
  expectPending(7)
  btnEnter()
  expectStack(7)
})

it('leftshift_7: should do nothing', () => {
  btnLeftShift()
  btn7()
  expectStack('')
})

it('rightshift_7: should do nothing', () => {
  btnRightShift()
  btn7()
  expectStack('')
})


it('should 8', () => {
  btn8()
  expectPending(8)
  btnEnter()
  expectStack(8)
})

it('leftshift_8: should do nothing', () => {
  btnLeftShift()
  btn8()
  expectStack('')
})

it('rightshift_8: should do nothing', () => {
  btnRightShift()
  btn8()
  expectStack('')
})


it('should 9', () => {
  btn9()
  expectPending(9)
  btnEnter()
  expectStack(9)
})

it('leftshift_9: should do nothing', () => {
  btnLeftShift()
  btn9()
  expectStack('')
})

it('rightshift_9: should do nothing', () => {
  btnRightShift()
  btn9()
  expectStack('')
})


it('dot: should show', () => {
  btn1()
  btnDot()
  btn3()
  btnEnter()
  expectStack('1.3')
})

it('leftshift_dot: should show tau', () => {
  btnTau()
  expect(getLcd().startsWith('\n\n\n\n6.2831853')).toBeTruthy()
})

it('rightshift_dot: should show pi', () => {
  btnPi()
  expect(getLcd().startsWith('\n\n\n\n3.14159265')).toBeTruthy()
})

it('clear: should remove pending entry', () => {
  btn3()
  btnEnter()
  btn4()
  btnEnter()
  btn5()
  expectPending([3,4,5])
  btnC()
  expectStack([3,4])
})

it('leftshift_clear: should remove pending entry', () => {
  btn3()
  btnEnter()
  btn4()
  btnEnter()
  btn5()
  expectPending([3,4,5])
  btnLeftShift()
  btnC()
  expectStack([3,4])
})

it('rightshift_clear: should remove pending entry', () => {
  btn3()
  btnEnter()
  btn4()
  btnEnter()
  btn5()
  expectPending([3,4,5])
  btnRightShift()
  btnC()
  expectStack([3,4])
})

it('clear: should not remove stack', () => {
  btn3()
  btnEnter()
  btn4()
  btnEnter()
  btn5()
  btnEnter()

  btnC()
  expectStack([3,4,5])
})


it('leftshift_clear: should not remove stack', () => {
  btn3()
  btnEnter()
  btn4()
  btnEnter()
  btn5()
  btnEnter()
  btnLeftShift()
  btnC()
  //expect(getLcd()).toEqual(toLcd([3,4,5]))
  expectStack([3,4,5])
})

it('rightshift_clear: should not remove stack', () => {
  btn3()
  btnEnter()
  btn4()
  btnEnter()
  btn5()
  btnEnter()
  btnRightShift()
  btnC()
  expectStack([3,4,5])
})


it('add: should add pending', () => {
  btn1()
  btnEnter()
  btn3()
  btnAdd()
  expectStack(4)
})

it('add: should add stack', () => {
  btn1()
  btnEnter()
  btn3()
  btnEnter()
  btnAdd()
  expectStack(4)
})


it('leftshift_add: should do nothing to pending', () => {
  btn1()
  btnEnter()
  btn3()
  expectPending([1,3])
  btnLeftShift()
  btnAdd()
  expectPending([1,3])
})

it('leftshift_add: should do nothing to stack', () => {
  btn1()
  btnEnter()
  btn3()
  btnEnter()
  btnLeftShift()
  btnAdd()
  expectStack([1, 3])
})


it('rightshift_add: should do nothing to pending', () => {
  btn1()
  btnEnter()
  btn3()
  expectPending([1,3])
  btnRightShift()
  btnAdd()
  expectPending([1,3])
})

it('rightshift_add: should do nothing to stack', () => {
  btn1()
  btnEnter()
  btn3()
  btnEnter()
  btnRightShift()
  btnAdd()
  expectStack([1,3])
})


it('subtract: should subtract pending', () => {
  btn3()
  btnEnter()
  btn1()
  btnSubtract()
  expectStack(2)
})

it('subtract: should subtract stack', () => {
  btn3()
  btnEnter()
  btn1()
  btnEnter()
  btnSubtract()
  expectStack(2)
})


it('leftshift_subtract: should do nothing to pending', () => {
  btn3()
  btnEnter()
  btn1()
  expectPending([3,1])
  btnLeftShift()
  btnSubtract()
  expectPending([3,1])
})

it('leftshift_subtract: should do nothing to stack', () => {
  btn3()
  btnEnter()
  btn1()
  btnEnter()
  expectStack([3,1])
  btnLeftShift()
  btnSubtract()
  expectStack([3,1])
})

it('rightshift_subtract: should do nothing to pending', () => {
  btn3()
  btnEnter()
  btn1()
  expectPending([3,1])
  btnRightShift()
  btnSubtract()
  expectPending([3,1])
})

it('rightshift_subtract: should do nothing to stack', () => {
  btn3()
  btnEnter()
  btn1()
  btnEnter()
  btnRightShift()
  btnSubtract()
  expectStack([3, 1])
})




it('multiply: should multiply pending', () => {
  btn3()
  btnEnter()
  btn2()
  expectPending([3,2])
  btnMultiply()
  expectStack(6)
})

it('multiply: should multiply stack', () => {
  btn3()
  btnEnter()
  btn2()
  btnEnter()
  expectStack([3,2])
  btnMultiply()
  expectStack(6)
})


it('leftshift_multiply: should do nothing to pending', () => {
  btn3()
  btnEnter()
  btn2()
  expectPending([3,2])
  btnLeftShift()
  btnMultiply()
  expectPending([3,2])
})

it('leftshift_multiply: should do nothing to stack', () => {
  btn3()
  btnEnter()
  btn2()
  btnEnter()
  expectStack([3,2])
  btnLeftShift()
  btnMultiply()
  expectStack([3,2])
})

it('rightshift_multiply: should do nothing to pending', () => {
  btn3()
  btnEnter()
  btn2()
  expectPending([3,2])
  btnRightShift()
  btnMultiply()
  expectPending([3,2])
})

it('rightshift_multiply: should do nothing to stack', () => {
  btn3()
  btnEnter()
  btn2()
  btnEnter()
  expectStack([3,2])
  btnRightShift()
  btnMultiply()
  expectStack([3,2])
})



it('divide: should divide pending', () => {
  btn6()
  btnEnter()
  btn2()
  expectPending([6,2])
  btnDivide()
  expectStack(3)
})

it('divide: should divide stack', () => {
  btn6()
  btnEnter()
  btn2()
  btnEnter()
  expectStack([6,2])
  btnDivide()
  expectStack(3)
})


it('leftshift_divide: should do nothing to pending', () => {
  btn6()
  btnEnter()
  btn2()
  expectPending([6,2])
  btnLeftShift()
  btnDivide()
  expectPending([6,2])
})

it('leftshift_divide: should do nothing to stack', () => {
  btn6()
  btnEnter()
  btn2()
  btnEnter()
  expectStack([6,2])
  btnLeftShift()
  btnDivide()
  expectStack([6,2])
})

it('rightshift_divide: should do nothing to pending', () => {
  btn6()
  btnEnter()
  btn2()
  expectPending([6,2])
  btnRightShift()
  btnDivide()
  expectPending([6,2])
})

it('rightshift_divide: should do nothing to stack', () => {
  btn6()
  btnEnter()
  btn2()
  btnEnter()
  btnRightShift()
  btnDivide()
  expect(getLcd()).toEqual(toLcd([6, 2]))
})


it('enter: should accept pending', () => {
  btn6()
  expectPending(6)
  btnEnter()
  expectStack(6)
})

it('enter: should duplicate bottom stack value', () => {
  btn6()
  btnEnter()
  expectStack(6)
  btnEnter()
  expectStack([6,6])
})

it('leftshift_enter: should do nothing to pending', () => {
  btn6()
  expectPending(6)
  btnLeftShift()
  btnEnter()
  expectPending(6)
})

it('leftshift_enter: should do nothing to stack', () => {
  btn6()
  btnEnter()
  expectStack(6)
  btnLeftShift()
  btnEnter()
  expectStack(6)
})

it('rightshift_enter: should do nothing to pending', () => {
  btn6()
  expectPending(6)
  btnRightShift()
  btnEnter()
  expectPending(6)
})

it('rightshift_enter: should do nothing to stack', () => {
  btn6()
  btnEnter()
  expectStack(6)
  btnRightShift()
  btnEnter()
  expectStack(6)
})

it('+/-: should alter pending sign', () => {
  btn9()
  expectPending(9)
  btnChangeSign()
  expectPending(-9)
  btnChangeSign()
  expectPending(9)
})

it('+/-: should alter stack sign', () => {
  btn9()
  btnEnter()
  expectStack(9)
  btnChangeSign()
  expectStack(-9)
  btnChangeSign()
  expectStack(9)
})

it('leftshift_+/-: (RAND) if pending, should be random integer less than pending value', () => {
  const attempts = 30 // Arbitrary
  for (let i=0; i<attempts; i++) {
      btn1()
      btn2()
      btnRand()
      const val = getLcd().trim()
      const intVal = parseInt(val)
      expect(intVal).toEqual(val)
      expect(intVal >= 0 && intVal < 12).toBeTruthy()
      btnDeleteChar() // Remove randomly generated integer.
  }
})

it('leftshift_+/-: (RAND) if stack, should be random float less than 1', () => {
  let oldVal = ''
  const attempts = 30 // Arbitrary
  for (let i=0; i<attempts; i++) {
      btnRand()
      const str = getLcd().trim()
      expect(str.length > 15)
      expect(str.startsWith('0.')).toBeTruthy()
      const flt = parseFloat(str)
      expect(flt < 1.0).toBeTruthy()
      expect(flt > 0.0).toBeTruthy()
      expect(str != oldVal).toBeTruthy()
      btnDeleteChar() // Remove value from stack
      oldVal = str
  }
})

it('rightshift_+/-: (MOD) should mod pending', () => {
  btn9()
  btnEnter()
  btn2()
  expectPending([9,2])
  btnMod()
  expectStack(1)
})

it('leftshift_+/-: (MOD) should mod stack', () => {
  btn9()
  btnEnter()
  btn2()
  btnEnter()
  expectStack([9,2])
  btnMod()
  expectStack(1)
})

it('eex: should prepend 1 automatically', () => {
  btnExpo()
  expectPending('1e')
})

it('eex: should exponent', () => {
  btn2()
  btnExpo()
  btn3()
  btnEnter()
  expectStack(2000)
})

it('leftshift_eex: (C(y,x)) should combination pending', () => {
  btn6()
  btnEnter()
  btn3()
  expectPending([6,3])
  btnCombo()
  expectStack(20)
})

it('leftshift_eex: (C(y,x)) should combination stack', () => {
  btn6()
  btnEnter()
  btn3()
  btnEnter()
  expectStack([6,3])
  btnCombo()
  expectStack(20)
})

it('rightshift_eex: (x!) should factorial pending', () => {
  btn5()
  expectPending(5)
  btnFact()
  expectStack(120)
})

it('rightshift_eex: (x!) should factorial stack', () => {
  btn5()
  btnEnter()
  expectStack(5)
  btnFact()
  expectStack(120)
})

it('delete: should remove 1 character from pending', () => {
  btn2()
  btn3()
  btn4()
  expectPending([234])
  btnDeleteChar()
  expectPending([23])
})

it('leftshift_delete: (none) should do nothing to pending', () => {
  btn2()
  btn3()
  btn4()
  expectPending([234])
  btnLeftShift()
  btnDeleteChar()
  expectPending([234])
})

it('leftshift_delete: (none) should do nothing to stack', () => {
  btn2()
  btn3()
  btn4()
  btnEnter()
  expectStack([234])
  btnLeftShift()
  btnDeleteChar()
  expectStack([234])
})

it('rightshift_delete: (CLEAR) should clear all when pending', () => {
  btn2()
  btnSto()
  btn3()
  expectPending(3)
  expect(getStoreInd()).toEqual('S=2')
  btnClear()
  expectStack('')
  expect(getStoreInd()).toEqual('')
})

it('rightshift_delete: (CLEAR) should clear all when stack', () => {
  btn2()
  btnSto()
  btn3()
  btnEnter()
  expectStack(3)
  expect(getStoreInd()).toEqual('S=2')
  btnClear()
  expectStack('')
})

it('sin: should sine pending', () => {
  btn3()
  btn0()
  expectPending(30)
  btnSin()
  expectStack('0.5')
})

it('sin: should sine stack', () => {
  btn3()
  btn0()
  btnEnter()
  expectStack(30)
  btnSin()
  expectStack('0.5')
})

it('leftshift_sin: (ASIN) should arcsine pending', () => {
  btn0()
  btnDot()
  btn5()
  expect(isBlinking()).toBeTruthy()
  btnAsin()
  expect(isBlinking()).toBeFalsy()
  expect(getLcd()).toEqual(toLcd(30))
})

it('leftshift_sin: (ASIN) should arcsine stack', () => {
  btn0()
  btnDot()
  btn5()
  btnEnter()
  expectStack('0.5')
  btnAsin()
  expectStack(30)
})

it('rightshift_sin: (none) should do nothing to pending', () => {
  btn0()
  btnDot()
  btn5()
  expectPending('0.5')
  btnRightShift()
  btnSin()
  expectPending('0.5')
})

it('rightshift_sin: (none) should do nothing to stack', () => {
  btn0()
  btnDot()
  btn5()
  btnEnter()
  btnRightShift()
  btnSin()
  expectStack('0.5')
})

it('cos: should cosine pending', () => {
  btn6()
  btn0()
  expectPending(60)
  btnCos()
  expectStack('0.5')
})

it('cos: should cosine stack', () => {
  btn6()
  btn0()
  btnEnter()
  expectStack(60)
  btnCos()
  expectStack('0.5')
})

it('leftshift_cos: (ACOS) should arcsine pending', () => {
  btn0()
  btnDot()
  btn5()
  expectPending('0.5')
  btnAcos()
  expectStack(60)
})

it('leftshift_cos: (ACOS) should arcsine stack', () => {
  btn0()
  btnDot()
  btn5()
  btnEnter()
  expectStack('0.5')
  btnAcos()
  expectStack(60)
})

it('rightshift_cos: (none) should do nothing to pending', () => {
  btn0()
  btnDot()
  btn5()
  expectPending('0.5')
  btnRightShift()
  btnCos()
  expectPending('0.5')
})

it('rightshift_cos: (none) should do nothing to stack', () => {
  btn0()
  btnDot()
  btn5()
  btnEnter()
  expectStack('0.5')
  btnRightShift()
  btnCos()
  expectStack('0.5')
})

it('tan: should tangent pending', () => {
  btn4()
  btn5()
  expectPending(45)
  btnTan()
  expectStack(1)
})

it('tan: should tangent stack', () => {
  btn4()
  btn5()
  btnEnter()
  expectStack(45)
  btnTan()
  expectStack(1)
})

it('leftshift_tan: (ATAN) should arctangent pending', () => {
  btn1()
  expectPending(1)
  btnAtan()
  expectStack(45)
})

it('leftshift_tan: (ATAN) should arctangent stack', () => {
  btn1()
  btnEnter()
  expectStack(1)
  btnAtan()
  expectStack(45)
})

it('rightshift_tan: (none) should do nothing to pending', () => {
  btn1()
  expectPending(1)
  btnRightShift()
  btnTan()
  expectPending(1)
})

it('rightshift_tan: (none) should do nothing to stack', () => {
  btn1()
  btnEnter()
  expectStack(1)
  btnRightShift()
  btnTan()
  expectStack(1)
})

it('1/x: should inverse pending', () => {
  btn4()
  expectPending(4)
  btnRecip()
  expectStack('0.25')
})

it('1/x: should inverse stack', () => {
  btn4()
  btnEnter()
  btnRecip()
  expect(getLcd()).toEqual(toLcd(0.25))
})

it('leftshift_1/x: (e^x) should exp pending', () => {
  btn2()
  expectPending(2)
  btnPowex()
  expect(isBlinking()).toBeFalsy()
  expect(getLcd().trim().startsWith('7.389056098')).toBeTruthy()
})

it('leftshift_1/x: (e^x) should exp stack', () => {
  btn2()
  btnEnter()
  expectStack(2)
  btnPowex()
  expect(getLcd().trim().startsWith('7.389056098')).toBeTruthy()
})

it('rightshift_1/x: (LN) should ln pending', () => {
  btn4()
  expectPending(4)
  btnLn()
  expect(isBlinking()).toBeFalsy()
  expect(getLcd().trim().startsWith('1.3862943611')).toBeTruthy()
})

it('rightshift_1/x: (LN) should ln stack', () => {
  btn4()
  btnEnter()
  expectStack(4)
  btnLn()
  expect(getLcd().trim().startsWith('1.3862943611')).toBeTruthy()
})

it('y^x: should pow pending', () => {
  btn2()
  btnEnter()
  btn3()
  expectPending([2,3])
  btnPowyx()
  expectStack(8)
})

it('y^x: should pow stack', () => {
  btn2()
  btnEnter()
  btn3()
  btnEnter()
  expectStack([2,3])
  btnPowyx()
  expectStack(8)
})

it('leftshift_y^x: (10^x) should pow10 pending', () => {
  btn3()
  expect(isBlinking()).toBeTruthy()
  expectPending(3)
  btnPow10x()
  expectStack(1000)
})

it('leftshift_y^x: (10^x) should pow10 stack', () => {
  btn3()
  btnEnter()
  expectStack(3)
  btnPow10x()
  expectStack(1000)
})

it('rightshift_y^x: (LOG) should log10 pending', () => {
  btn1()
  btn0()
  btn0()
  expectPending(100)
  btnLog()
  expectStack(2)
})

it('rightshift_y^x: (LOG) should log10 stack', () => {
  btn1()
  btn0()
  btn0()
  btnEnter()
  expectStack(100)
  btnLog()
  expectStack(2)
})

it('sto: should store pending', () => {
  expect(getStoreInd()).toEqual('')
  btn3()
  expectPending(3)
  btnSto()
  expect(getStoreInd()).toEqual('S=3')
  expectStack('')
})

it('sto: should store stack', () => {
  expect(getStoreInd()).toEqual('')
  btn3()
  btnEnter()
  expectStack(3)
  btnSto()
  expect(getStoreInd()).toEqual('S=3')
  expectStack('')
})

it('leftshift_sto: (RCL) should recall pending', () => {
  btn3()
  btnSto()
  btn5()
  expectPending(5)
  btnRcl()
  expectStack([5,3])
  expect(getStoreInd()).toEqual('S=3')
})

it('leftshift_sto: (RCL) should recall stack', () => {
  btn3()
  btnSto()
  btn5()
  btnEnter()
  expectStack(5)
  btnRcl()
  expectStack([5,3])
  expect(getStoreInd()).toEqual('S=3')
})

it('rightshift_sto: (AND) should And pending', () => {
  btn5()
  btnEnter()
  btn3()
  expectPending([5,3])
  btnAnd()
  expectStack(1)
})

it('rightshift_sto: (AND) should And stack', () => {
  btn5()
  btnEnter()
  btn3()
  btnEnter()
  expectStack([5,3])
  btnAnd()
  expectStack(1)
})

it('disp: should change precision when pending', () => {
  expect(getPrecisionInd()).toEqual('ALL')
  btnDisp()
  expect(getPrecisionInd()).toEqual('FIX')
  btnDisp()
  // Start on SCI because FIX consumes a pending value.
  expect(getPrecisionInd()).toEqual('SCI')
  btn2()
  expectPending(2)
  btnDisp()
  expect(getPrecisionInd()).toEqual('ALL')
  expectPending(2)
  btnDisp()
  expect(getPrecisionInd()).toEqual('FIX')
  expectPending(2)
})

it('disp: pending integer value should set precision', () => {
  btn7()
  btnEnter()
  expectStack(7)
  expect(getPrecisionInd()).toEqual('ALL')
  btnDisp()
  expect(getPrecisionInd()).toEqual('FIX')
  btn2()
  expectPending(['7.0000','2'])
  btnDisp()
  expectStack('7.00')
  expect(getPrecisionInd()).toEqual('FIX')
  btnDisp()
  expect(getPrecisionInd()).toEqual('SCI')
  expectStack('7.00e+0')
  btnDisp()
  expect(getPrecisionInd()).toEqual('ALL')
  expectStack(7)
})

it('disp: pending non-integer value should set not set precision', () => {
  btn7()
  btnEnter()
  expectStack(7)
  btnDisp()
  expect(getPrecisionInd()).toEqual('FIX')
  btn1()
  btnDot()
  btn2()
  btn8()
  expectPending(['7.0000', '1.28'])
  btnDisp()
  expectPending(['7.0000e+0', '1.28'])
  expect(getPrecisionInd()).toEqual('SCI')
})

it('disp: pending negative value should not set precision', () => {
  btn7()
  btnEnter()
  expectStack(7)
  btnDisp()
  expect(getPrecisionInd()).toEqual('FIX')
  btn1()
  btnChangeSign()
  expectPending(['7.0000', '-1'])
  btnDisp()
  expectPending(['7.0000e+0', '-1'])
  expect(getPrecisionInd()).toEqual('SCI')
})

it('disp: pending integer 16 should set precision', () => {
  btn7()
  btnEnter()
  expectStack(7)
  btnDisp()
  expect(getPrecisionInd()).toEqual('FIX')
  btn1()
  btn6()
  expectPending(['7.0000', '16'])
  btnDisp()
  expectStack('7.0000000000000000')
  expect(getPrecisionInd()).toEqual('FIX')
})

it('disp: pending integer greater than 16 should set precision to 16', () => {
  btn7()
  btnEnter()
  expectStack(7)
  btnDisp()
  expect(getPrecisionInd()).toEqual('FIX')
  btn1()
  btn7()
  expectPending(['7.0000', '17'])
  btnDisp()
  expectStack('7.0000000000000000')
  expect(getPrecisionInd()).toEqual('FIX')
})

it('disp: should change disp when stack', () => {
  btn7()
  btnEnter()
  expectStack(7)
  expect(getPrecisionInd()).toEqual('ALL')
  btnDisp()
  expect(getPrecisionInd()).toEqual('FIX')
  expectStack('7.0000')
  btnDisp()
  expect(getPrecisionInd()).toEqual('SCI')
  expectStack('7.0000e+0')
})

it('leftshift_disp: (none) should do nothing to pending', () => {
  btn5()
  expectPending(5)
  btnLeftShift()
  btnDisp()
  expectPending(5)
})

it('leftshift_disp: (none) should do nothing to stack', () => {
  btn5()
  btnEnter()
  expectStack(5)
  btnLeftShift()
  btnDisp()
  expectStack(5)
})

it('rightshift_disp: (NOT) should Not pending', () => {
  btn5()
  expectPending(5)
  btnNot()
  expectStack(-6)
})

it('rightshift_disp: (NOT) should Not stack', () => {
  btn5()
  btnEnter()
  expectStack(5)
  btnNot()
  expectStack(-6)
})

it('base: should change base and accept pending', () => {
  expect(getBaseInd()).toEqual('10')

  btn1()
  expectPending(1)
  btnBase()
  expect(getBaseInd()).toEqual('16')
  expectStack('0x1')
  btnDeleteChar()

  btn1()
  expectPending(1)
  btnBase()
  expectStack('0b00000001')
  btnDeleteChar()

  btn1()
  expectPending(1)
  btnBase()
  expectStack('0o1')
  btnDeleteChar()

  btn1()
  expectPending(1)
  btnBase()
  expect(getBaseInd()).toEqual('10')
  expectStack(1)
  btnDeleteChar()
})

it('base: should change base and not alter stack', () => {
  expect(getBaseInd()).toEqual('10')
  btn1()
  btnEnter()
  expectStack(1)
  btnBase()
  expect(getBaseInd()).toEqual('16')
  expectStack('0x1')
  btnBase()
  expect(getBaseInd()).toEqual('2')
  expectStack('0b00000001')
  btnBase()
  expect(getBaseInd()).toEqual('8')
  expectStack('0o1')
  btnBase()
  expect(getBaseInd()).toEqual('10')
  expectStack(1)
})

it('leftshift_base: (MODE) should change mode if pending', () => {
  expect(getModeInd()).toEqual('DEG')
  btn6()
  expectPending(6)
  btnMode()
  expect(getModeInd()).toEqual('RAD')
  expectPending(6)
  btnMode()
  expect(getModeInd()).toEqual('DEG')
})

it('leftshift_base: (MODE) should change mode if stack', () => {
  expect(getModeInd()).toEqual('DEG')
  btn6()
  btnEnter()
  expectStack(6)
  btnMode()
  expect(getModeInd()).toEqual('RAD')
  expectStack(6)
  btnMode()
  expect(getModeInd()).toEqual('DEG')
})

it('rightshift_base: (OR) should Or pending', () => {
  btn5()
  btnEnter()
  btn3()
  expectPending([5,3])
  btnOr()
  expectStack(7)
})

it('rightshift_base: (OR) should Or stack', () => {
  btn5()
  btnEnter()
  btn3()
  btnEnter()
  expectStack([5,3])
  btnOr()
  expectStack(7)
})


it('sqrt: should sqrt pending', () => {
  btn9()
  expectPending(9)
  btnSqrt()
  expectStack(3)
})

it('sqrt: should sqrt stack', () => {
  btn9()
  btnEnter()
  expectStack(9)
  btnSqrt()
  expectStack(3)
})

it('leftshift_sqrt: (rootxy) should Rootxy pending', () => {
  btn8()
  btnEnter()
  btn3()
  expectPending([8,3])
  btnRootxy()
  expectStack(2)
})

it('leftshift_sqrt: (rootxy) should Rootxy stack', () => {
  btn8()
  btnEnter()
  btn3()
  btnEnter()
  expectStack([8,3])
  btnRootxy()
  expectStack(2)
})

it('rightshift_sqrt: (XOR) should Xor pending', () => {
  btn5()
  btnEnter()
  btn3()
  expectPending([5,3])
  btnXor()
  expectStack(6)
})

it('rightshift_sqrt: (XOR) should ln stack', () => {
  btn5()
  btnEnter()
  btn3()
  btnEnter()
  expectStack([5,3])
  btnXor()
  expectStack(6)
})

it('swap: should swap when pending', () => {
  btn2()
  btnEnter()
  btn3()
  expectPending([2,3])
  btnSwap()
  expectStack([3,2])
})

it('swap: should swap when stack', () => {
  btn2()
  btnEnter()
  btn3()
  btnEnter()
  expectStack([2,3])
  btnSwap()
  expectStack([3,2])
})

it('leftshift_swap: (none) should do nothing to pending', () => {
  btn2()
  btnEnter()
  btn3()
  expectPending([2,3])
  btnLeftShift()
  btnSwap()
  expectPending([2,3])
})

it('leftshift_swap: (none) should do nothing to stack', () => {
  btn2()
  btnEnter()
  btn3()
  btnEnter()
  expectStack([2,3])
  btnLeftShift()
  btnSwap()
  expectStack([2,3])
})

it('rightshift_swap: (UNDO) should undo pending operation', () => {
  btn2()
  btnEnter()
  btn3()
  expectPending([2,3])
  btnAdd()
  expectStack(5)
  btnUndo()
  expectStack([2,3])
})

it('rightshift_swap: (UNDO) should undo stack operation', () => {
  btn2()
  btnEnter()
  btn3()
  btnEnter()
  expectStack([2,3])
  btnAdd()
  expectStack(5)
  btnUndo()
  expectStack([2,3])
})


// ####################################################

it('default mode to degrees', () => {
    expect(getModeInd()).toEqual('DEG')
    btn3()
    btn0()
    btnEnter()
    expectStack(30)
    btnSin()
    expectStack('0.5')
})

it('should calculate radians', () => {
    expect(getModeInd()).toEqual('DEG')
    btnMode()
    expect(getModeInd()).toEqual('RAD')
    btnTau()
    btn4()
    btnDivide()
    btnSin()
    expect(getLcd()).toEqual(toLcd('1'))
})

it('should accept decimal point without leading zero', () => {
    btnDot()
    expectPending('.')
    btn4()
    expectPending('.4')
    btnEnter()
    expectStack('0.4')
})

it('should not accept two decimal points', () => {
    btn1()
    btnDot()
    expectPending('1.')
    btnDot()
    expectPending('1.')
    btn3()
    expectPending('1.3')
    btnDot()
    expectPending('1.3')
})

it('should accept exponent with no prefix', () => {
    btnExpo()
    expectPending('1e')
    btn2()
    expectPending('1e2')
    btnEnter()
    expectStack('100')
})

it('should ignore missing exponent', () => {
    btn1()
    btnDot()
    btn4()
    btnExpo()
    expectPending('1.4e')
    btnEnter()
    expectStack('1.4')
})

it('should not accept two exponents', () => {
    btn1()
    btnExpo()
    expectPending('1e')
    btnExpo()
    expectPending('1e')
    btn2()
    expectPending('1e2')
})

it('should negate exponent', () => {
    btnExpo()
    btn2()
    expectPending('1e2')
    btnChangeSign()
    expectPending('1e-2')
    btnChangeSign()
    expectPending('1e2')
})


it('should accept bin values', () => {
    btnBase()
    btnBase()
    expect(getBaseInd()).toEqual('2')
    btn1()
    btn0()
    expectPending(10)
    btn2()
    btn3()
    btn4()
    btn5()
    btn6()
    btn7()
    btn8()
    btn9()
    btnDot()
    expectPending(10)
    btnEnter()
    expectStack('0b00000010')
})

it('should accept oct values', () => {
    btnBase()
    btnBase()
    btnBase()
    expect(getBaseInd()).toEqual('8')
    btn7()
    btn6()
    btn5()
    btn4()
    btn3()
    btn2()
    btn1()
    btn0()
    expectPending(76543210)
    btn8()
    btn9()
    btnDot()
    expectPending(76543210)
    btnEnter()
    expectStack('0o76543210')
})

it('should accept dec values', () => {
    expect(getBaseInd()).toEqual('10')
    btn9()
    btn8()
    btn7()
    btn6()
    btnDot()
    btn5()
    btn4()
    btn3()
    btn2()
    btn0()
    btn1()
    expectPending('9876.543201')
    btnEnter()
    expectStack('9876.543201')
})

it('should accept hex values', () => {
    btnBase()
    expect(getBaseInd()).toEqual('16')
    btn9()
    btn8()
    btn7()
    btn6()
    btn5()
    btn4()
    btn3()
    btn2()
    expectPending('98765432')
    btnEnter()
    expectStack('0x98765432')
    btnDeleteChar()
    
    btn1()
    btn0()
    btnHexA()
    btnHexB()
    btnHexC()
    btnHexD()
    btnHexE()
    btnHexF()
    expectPending('10ABCDEF')
    btnEnter()
    expectStack('0x10ABCDEF')
})

it('base2 should format 32-bit binary', () => {
    btn2()
    btnEnter()
    btn3()
    btn1()
    btnEnter()
    expectStack([2,31])
    btnPowyx()
    btnBase()
    btnBase()
    expect(getBaseInd()).toEqual(2)
    expectStack('0b10000000_00000000_00000000_00000000')
})

it('base2 negative values should be prefixed with eight 1s', () => {
    btn5()
    btnChangeSign()
    btnBase()
    btnBase()
    expect(getBaseInd()).toEqual('2')
    expectStack('0b11111111_11111011')
})

it('base2 should allow an exponent', () => {
    btnBase()
    btnBase()
    expect(getBaseInd()).toEqual('2')
    btn1()
    btn0()
    btnExpo()
    btn1()
    btn0()
    btn1()
    expectPending('10e101')
    btnEnter()
    expectStack('0b00000011_00001101_01000000')
})

it('base8 should allow an exponent', () => {
    btnBase()
    btnBase()
    btnBase()
    expect(getBaseInd()).toEqual('8')
    btn6()
    btnExpo()
    btn3()
    expectPending('6e3')
    btnEnter()
    expectStack('0o13560')
})

it('base8 negative values should be prefixed with minus sign', () => {
    btnBase()
    btnBase()
    btnBase()
    expect(getBaseInd()).toEqual('8')
    btn4()
    btnChangeSign()
    expectPending('-4')
    btnEnter()
    expectStack('-0o4')
})

it('base16 should allow an exponent', () => {
    btnBase()
    expect(getBaseInd()).toEqual('16')
    btnHexB()
    btnExpo()
    btnHexA()
    expectPending('BeA')
    btnEnter()
    expectStack('0x199C82CC00')
})

it('base16 negative values should be prefixed with minus sign', () => {
    btnBase()
    expect(getBaseInd()).toEqual('16')
    btnHexA()
    btnChangeSign()
    expectPending('-A')
    btnEnter()
    expectStack('-0xA')
})

it('should store a large stack', () => {
    const stk = []
    const limit = 100 // Arbitrary
    for (let i=0; i<limit; i++) {
        if (i % 10 == 0) { btn0(); stk.unshift(0) }
        if (i % 10 == 1) { btn1(); stk.unshift(1) }
        if (i % 10 == 2) { btn2(); stk.unshift(2) }
        if (i % 10 == 3) { btn3(); stk.unshift(3) }
        if (i % 10 == 4) { btn4(); stk.unshift(4) }
        if (i % 10 == 5) { btn5(); stk.unshift(5) }
        if (i % 10 == 6) { btn6(); stk.unshift(6) }
        if (i % 10 == 7) { btn7(); stk.unshift(7) }
        if (i % 10 == 8) { btn8(); stk.unshift(8) }
        if (i % 10 == 9) { btn9(); stk.unshift(9) }
        btnEnter()
    }
    expect(STACK).toEqual(stk)
    expectStack(stk.slice(0,4).reverse())
})


it('should handle keyboard base10 numbers', () => {
    _kbd('9')
    _kbd('8')
    _kbd('7')
    _kbd('6')
    _kbd('5')
    _kbd('4')
    _kbd('3')
    _kbd('2')
    _kbd('1')
    _kbd('0')
    _kbd('.')
    _kbd('5')
    expectPending('9876543210.5')
})
//    _kbd('.')

it('should handle keyboard base16 numbers', () => {
    _kbd('b')
    expect(getBaseInd()).toEqual('16')
    _kbd('F')
    _kbd('E')
    _kbd('D')
    _kbd('C')
    _kbd('B')
    _kbd('A')
    expectPending('FEDCBA')
})

it('should handle keyboard backspace, escape', () => {
    _kbd('4')
    _kbd('5')
    _kbd('Enter')

    _kbd('1')
    _kbd('2')
    _kbd('3')
    expectPending(['45', '123'])
    _kbd('Backspace')
    expectPending(['45', '12'])
    _kbd('Escape')
    expectStack('45')
})

it('should handle keyboard +, -, /, *', () => {
    _kbd('6')
    _kbd('Enter')
    _kbd('2')
    _kbd('+')
    expectStack('8')
    _kbd('Backspace')

    _kbd('6')
    _kbd('Enter')
    _kbd('2')
    _kbd('-')
    expectStack('4')
    _kbd('Backspace')

    _kbd('6')
    _kbd('Enter')
    _kbd('2')
    _kbd('/')
    expectStack('3')
    _kbd('Backspace')

    _kbd('6')
    _kbd('Enter')
    _kbd('2')
    _kbd('*')
    expectStack('12')
    _kbd('Backspace')
})

it('should handle keyboard leftShift, rightShift', () => {
    expect(getLeftShiftInd()).toEqual('')
    _kbd('[')
    expect(getLeftShiftInd()).toEqual(getLeftShiftIndChar())
    _kbd('[')
    expect(getLeftShiftInd()).toEqual('')

    expect(getRightShiftInd()).toEqual('')
    _kbd(']')
    expect(getRightShiftInd()).toEqual(getRightShiftIndChar())
    _kbd(']')
    expect(getRightShiftInd()).toEqual('')
})

it('should handle keyboard Base', () => {
    expect(getBaseInd()).toEqual('10')
    _kbd('b')
    expect(getBaseInd()).toEqual('16')
})

it('should handle keyboard Sin', () => {
    _kbd('3')
    _kbd('0')
    expectPending('30')
    _kbd('s')
    expectStack('0.5')
})

it('should handle keyboard Cos', () => {
    _kbd('6')
    _kbd('0')
    expectPending('60')
    _kbd('c')
    expectStack('0.5')
})

it('should handle keyboard Tan', () => {
    _kbd('4')
    _kbd('5')
    expectPending('45')
    _kbd('t')
    expectStack('1')
})

it('should handle keyboard BASE', () => {
    expect(getBaseInd()).toEqual('10')
    _kbd('b')
    expect(getBaseInd()).toEqual('16')
})

it('should handle keyboard DISP', () => {
    expect(getPrecisionInd()).toEqual('ALL')
    _kbd('d')
    expect(getPrecisionInd()).toEqual('FIX')
})

it('should handle keyboard EEX', () => {
    _kbd('e')
    _kbd('3')
    expectPending('1e3')
})

it('should handle keyboard STO', () => {
    expect(getStoreInd()).toEqual('')
    _kbd('3')
    _kbd('o')
    expect(getStoreInd()).toEqual('S=3')
    expectStack('')
})

it('should handle keyboard +/-', () => {
    _kbd('3')
    expectPending('3')
    _kbd('p') // plus/minus
    expectPending('-3')
})

it('should handle keyboard SQRT', () => {
    _kbd('9')
    _kbd('q')
    expectStack('3')
})

it('should handle keyboard RECIP', () => {
    _kbd('4')
    _kbd('r')
    expectStack('0.25')
})
it('should handle keyboard SWAP', () => {
    _kbd('4')
    _kbd('Enter')
    _kbd('3')
    _kbd('w')
    expectStack([3,4])
})

it('should handle keyboard POWYX', () => {
    _kbd('2')
    _kbd('Enter')
    _kbd('3')
    _kbd('y')
    expectStack(8)
})


all_tests_passed()   // Update the LCD with test results.
}


function resizeButtonHeight() {
    const lcdEl = document.getElementById('lcd')
    const textareaHeight = lcdEl.offsetHeight
    const visibleHeight = window.innerHeight
    const numRows = 7
    const rowHeight = (visibleHeight - textareaHeight) / numRows
    document.querySelectorAll('td.tds').forEach((el, i) => {
        el.height = parseInt(rowHeight-5)+'px'
    })
}



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


function getKeyName(evt) {
    if (window.event) {
        //return window.event.keyCode
        return window.event.key
    } else if (evt) {
        return evt.which // IE
    }
    return null
}

function _kbd(keyName) {
    if (keyName == 'Enter') {
        btnEnter()
    } else if (keyName == "Backspace" ) {
        btnDeleteChar()
    } else if (keyName == "Escape" ) {
        btnC()
    } else if (keyName == '0') {
        btn0()
    } else if (keyName == '1') {
        btn1()
    } else if (keyName == '2') {
        btn2()
    } else if (keyName == '3') {
        btn3()
    } else if (keyName == '4') {
        btn4()
    } else if (keyName == '5') {
        btn5()
    } else if (keyName == '6') {
        btn6()
    } else if (keyName == '7') {
        btn7()
    } else if (keyName == '8') {
        btn8()
    } else if (keyName == '9') {
        btn9()
    } else if (keyName == 'A') {
        rightShiftOn()
        btn0()
    } else if (keyName == 'B') {
        rightShiftOn()
        btn1()
    } else if (keyName == 'C') {
        rightShiftOn()
        btn2()
    } else if (keyName == 'D') {
        rightShiftOn()
        btn3()
    } else if (keyName == 'E') {
        rightShiftOn()
        btn4()
    } else if (keyName == 'F') {
        rightShiftOn()
        btn5()
    } else if (keyName == '.') {
        btnDot()
    } else if (keyName == "-" ) {
        btnSubtract()
    } else if (keyName == "+" ) {
        btnAdd()
    } else if (keyName == "*" ) {
        btnMultiply()
    } else if (keyName == "/" ) {
        btnDivide()
    } else if (keyName == "b" ) {
        btnBase()
    } else if (keyName == "c" ) {
        btnCos()
    } else if (keyName == "d" ) {
        btnDisp()
    } else if (keyName == "e" ) {
        btnExpo()
    } else if (keyName == "o" ) {
        btnSto()
    } else if (keyName == "p" ) {
        btnChangeSign()
    } else if (keyName == "q" ) {
        btnSqrt()
    } else if (keyName == "r" ) {
        btnRecip()
    } else if (keyName == "s" ) {
        btnSin()
    } else if (keyName == "t" ) {
        btnTan()
    } else if (keyName == "w" ) {
        btnSwap()
    } else if (keyName == "y" ) {
        btnPowyx()
    } else if (keyName == "[" ) {
        btnLeftShift()
    } else if (keyName == "]" ) {
        btnRightShift()
    }
}

// This does not have a key for 'clear'
function kbd() {
    _kbd(getKeyName())
}



// #############################################################
// ###### OPERATIONS
// #############################################################

function add() {
    if (_has(2)) {
        const ans = parseFloat(STACK[1]) + parseFloat(STACK[0])
        _drop(2)
        STACK.unshift(ans)
    }
}


function arccos() {
    if (_has(1)) {
        STACK[0] = Math.acos(parseFloat(STACK[0]))/MODE_CONV
    }
}

function arcsin() {
    if (_has(1)) {
        STACK[0] = Math.asin(parseFloat(STACK[0]))/MODE_CONV
    }
}

function arctan() {
    if (_has(1)) {
        // four-quatrant inverse tangent
        // STACK[1] = Math.atan2(parseFloat(STACK[1], STACK[0]))/MODE_CONV
        // _drop()
        // two-quadrant inverse tangent
        STACK[0] = Math.atan(parseFloat(STACK[0]))/MODE_CONV
    }
}

function _to32bit(val) {
      let intVal = parseInt(val)
      const posVal = Math.abs(MIN_BITWISE_VAL)-1
      if (intVal > posVal) {
          console.log('too large. clipping.')
          intVal = posVal
      }
      if (intVal < MIN_BITWISE_VAL) {
          console.log('too small. clipping.')
          intVal = MIN_BITWISE_VAL
      }
      return intVal
}

function bitwiseAnd() {
    if (_has(2)) {
        if (_isInt(STACK[0]) && _isInt(STACK[1])) {
            // Bitwise operations are 32-bit. Larger values are truncated.
            const a = _to32bit(STACK[0])
            const b = _to32bit(STACK[1])
            STACK[1] = a & b
            _drop()
        }
    }
}

function bitwiseNot() {
    if (_has(1)) {
        if (_isInt(STACK[0])) {
            // Bitwise operations are 32-bit. Larger values are truncated.
            const val = _to32bit(STACK[0])
            STACK[0] = ~val
        }
    }

}

function bitwiseOr() {
    if (_has(2)) {
        if (_isInt(STACK[0]) && _isInt(STACK[1])) {
            // Bitwise operations are 32-bit. Larger values are truncated.
            const a = _to32bit(STACK[0])
            const b = _to32bit(STACK[1])
            STACK[1] = a | b
            _drop()
        }
    }
}

function bitwiseXor() {
    if (_has(2)) {
        if (_isInt(STACK[0]) && _isInt(STACK[1])) {
            // Bitwise operations are 32-bit. Larger values are truncated.
            const a = _to32bit(STACK[0])
            const b = _to32bit(STACK[1])
            STACK[1] = a ^ b
            _drop()
        }
    }
}

function inputPi() {
    if (_isPending()) {
        enterKey()
    }
    STACK.unshift(Math.PI)
}

function inputTau() {
    if (_isPending()) {
        enterKey()
    }
    STACK.unshift(2*Math.PI)
}

function combination() {
    if (_has(2)) {
        if (_isInt(STACK[0]) && _isInt(STACK[1])) {
            const m = parseInt(STACK[0])
            const n = parseInt(STACK[1])
            STACK[1] = _fact(n) / (_fact(m) * _fact(n-m))
            _drop()
        }
    }
}

function cos() {
    if (_has(1)) {
        STACK[0] = Math.cos(parseFloat(STACK[0]) * MODE_CONV)
    }
}

function drop() {
    if (_has(1)) {
        _drop()
    }
}

function divide() {
    if (_has(2)) {
        const ans = parseFloat(STACK[1]) / parseFloat(STACK[0])
        _drop(2)
        STACK.unshift(ans)
    }
}

function factorial() {
    if (_has(1)) {
        // STACK[0] = _gammaFact(parseInt(STACK[0]))
        STACK[0] = _gammaFact(parseFloat(STACK[0]))
    }
}

function lnx() {
    if (_has(1)) {
         STACK[0] = Math.log(parseFloat(STACK[0]))
    }
}

function logx() {
    if (_has(1)) {
         STACK[0] = Math.log10(parseFloat(STACK[0]))
    }
}

function multiply() {
    if (_has(2)) {
        STACK[1] = parseFloat(STACK[1]) * parseFloat(STACK[0])
        _drop()
    }
}

function mod() {
    if (_has(2)) {
        if (_isInt(STACK[0]) && _isInt(STACK[1])) {
            const i0 = parseInt(STACK[0])
            const i1 = parseInt(STACK[1])
            STACK[1] = i1 % i0
            _drop()
        }
    }
}

function negate() {
    if (_isPending() || _has(1)) {
        let str = (_isPending() ? PENDING : ''+STACK[0])
        let doNegate = true
        if (_isPending()) {
            str = PENDING
            // let negEPos = str.indexOf('E-')
            // let posEPos = str.indexOf('E')
            let negEPos = str.indexOf(EXPO_CHR+'-')
            let posEPos = str.indexOf(EXPO_CHR)
            if (negEPos >= 0) {
                str = str.substring(0, negEPos+1) + str.substring(negEPos+2)
                doNegate = false
            } else if (posEPos >= 0) {
                str = str.substring(0, posEPos+1) + '-' + str.substring(posEPos+1)
                doNegate = false
            }
        }
        if (doNegate) {
            if (str.startsWith('-')) {
                str = str.substring(1)
            } else {
                str = '-' + str
            }
        }
        if (_isPending()) {
            PENDING = str
        } else {
            STACK[0] = str
        }
    }
}

function powex() {
    if (_has(1)) {
         STACK[0] = Math.exp(parseFloat(STACK[0]))
    }
}

function pow10x() {
    if (_has(1)) {
         STACK[0] = Math.pow(10, parseFloat(STACK[0]))
    }
}

function powyx() {
    if (_has(2)) {
      STACK[1] = Math.pow(parseFloat(STACK[1]),parseFloat(STACK[0]))
      _drop()
    }
}

function _rootxy(x, y) {
    var tmp = Math.log(y) / x
    return Math.pow(Math.E, tmp)
}

function rootxy() {
    if (_has(2)) {
      const x = parseFloat(STACK[0])
      const y = parseFloat(STACK[1])
      STACK[1] = _rootxy(x, y)
      _drop()
    }
}

function rand() {
    if (_isPending()) {
        if (_isInt(PENDING)) {
            enterKey()
            STACK[0] = parseInt(Math.random() * parseInt(STACK[0]))
        }
    } else {
        STACK.unshift(Math.random())
    }
}

function sin() {
    if (_has(1)) {
        STACK[0] = Math.sin(parseFloat(STACK[0]) * MODE_CONV)
    }
}

function sqrt() {
    if (_has(1)) {
        STACK[0] = Math.sqrt(parseFloat(STACK[0]))
    }
}

function swapxy() {
    if (_has(2)) {
        const tmp = STACK[0]
        STACK[0] = STACK[1]
        STACK[1] = tmp
    }
}

function tan() {
    if (_has(1)) {
        STACK[0] = Math.tan(parseFloat(STACK[0]) * MODE_CONV)
    }
}

function undoPrevOp() {
    STACK=[]
    for(var i=0; i<SAVED_STACK.length; i++) {
        STACK.push(SAVED_STACK[i])
    }
    _updateLcd()
}

function _parsePendingAsBase(base) {
    const pos = PENDING.indexOf(EXPO_CHR)
    if (pos >= 0) {
        const mantissa = parseInt(PENDING.substring(0, pos), base)
        const exponent = parseInt(PENDING.substring(pos+1), base)
        const base10Val = Number(mantissa + EXPO_CHR + exponent)
        return base10Val
    } else {
        return parseInt(PENDING, base)
    }
}

function enterKey() {
    if (_isPending()) {
        let val = ''
        if (isBaseBin()) {
            val = _parsePendingAsBase(2)
        } else if (isBaseOct()) {
            val = _parsePendingAsBase(8)
        } else if (isBaseDec()) {
            val = PENDING
        } else if (isBaseHex()) {
            val = _parsePendingAsBase(16)
        }
        STACK.unshift(val)
        _clearPending()
        if (isLeftShifted()) {
            // None
        } else if (isRightShifted()) {
            // None
        } else {
        }
    } else {
        STACK.unshift(STACK[0])
    }
    _updateLcd()
}


function recallx() {
    if (STORED_X) {
        if (_isPending()) {
            enterKey()
        }
        STACK.unshift(STORED_X)
    }
}

function reciprocal() {
    if (_has(1)) {
        STACK[0] = 1 / parseFloat(STACK[0])
    }
}

function storex() {
    if (_isPending()) {
        enterKey()
    }
    if (_has(1)) {
        STORED_X = STACK[0]
        _drop()
    }
}

function subtract() {
    if (_has(2)) {
        const ans = parseFloat(STACK[1]) - parseFloat(STACK[0])
        _drop(2)
        STACK.unshift(ans)
    }
}

function _isBlinking() {
    return IS_BLINKING
}

function fin() {
    rightShiftOff()
    leftShiftOff()
    _updateLcd()
}

function inputStr(str) {
    let isOk = true
    if (isBaseBin() && str.match(/[^01e]/g)) {
        isOk = false
    } else if (isBaseOct() && str.match(/[^012345678e]/g)) {
        isOk = false
    } else if (isBaseDec()) {
        let chkStr = str
        if (_isPending()) {
            if (str.startsWith('.')) {
                chkStr = '0'+str
            }
        } else {
            if (str == EXPO_CHR) {
                str = '1'+str
                chkStr = str
            } else if (str == '.') {
                chkStr = '0'+str
            }
        }
        if (!_isValidNumber(PENDING+chkStr)) {
            isOk = false
        }
    } else if (isBaseHex() && str.match(/[^0123456789ABCDEFe]/g)) {
        isOk = false
    }


    if (isOk) {
        if (!_isBlinking()) {
            _startBlinking()
        }
        if (isBaseHex() && str != EXPO_CHR) {
        // Must be uppercase to distinguish EEX exponent from 0xE
            str = str.toUpperCase()
        }
        PENDING += str
    } else {
        console.log('invalid entry ignored', str)
    }
}


function _isValidNumber(str) {
    if (typeof str === 'string') {
        // if (str.slice(-1) == 'E') { // Allow exponents
        if (str.slice(-1) == EXPO_CHR) { // Allow exponents
            str += '1'
        }
        return !isNaN(+str)
    }
    return false
}

// #############################################################
// ###### BUTTONS
// #############################################################
// All 'btn...()' functions return false to prevent default 'click' action.

function btn0() {
    if (isLeftShifted()) {
        // None
    } else if (isRightShifted()) {
        if (isBaseHex()) {
            inputStr('A')
        }
    } else {
        inputStr('0')
    }
    fin()
    return false
}

function btn1() {
    if (isLeftShifted()) {
        // None
    } else if (isRightShifted()) {
        if (isBaseHex()) {
            inputStr('B')
        }
    } else {
        inputStr('1')
    }
    fin()
    return false
}

function btn2() {
    if (isLeftShifted()) {
        // None
    } else if (isRightShifted()) {
        if (isBaseHex()) {
            inputStr('C')
        }
    } else {
        if (isBaseOct() || isBaseDec() || isBaseHex()) {
            inputStr('2')
        }
    }
    fin()
    return false
}

function btn3() {
    if (isLeftShifted()) {
        // None
    } else if (isRightShifted()) {
        if (isBaseHex()) {
            inputStr('D')
        }
    } else {
        if (isBaseOct() || isBaseDec() || isBaseHex()) {
            inputStr('3')
        }
    }
    fin()
    return false
}

function btn4() {
    if (isLeftShifted()) {
        // None
    } else if (isRightShifted()) {
        if (isBaseHex()) {
            inputStr('E')
            //inputStr(EXPO_CHR)
        }
    } else {
        if (isBaseOct() || isBaseDec() || isBaseHex()) {
            inputStr('4')
        }
    }
    fin()
    return false
}

function btn5() {
    if (isLeftShifted()) {
        // None
    } else if (isRightShifted()) {
        if (isBaseHex()) {
            inputStr('F')
        }
    } else {
        if (isBaseOct() || isBaseDec() || isBaseHex()) {
            inputStr('5')
        }
    }
    fin()
    return false
}

function btn6() {
    if (isLeftShifted()) {
        // None
    } else if (isRightShifted()) {
        // None
    } else {
        if (isBaseOct() || isBaseDec() || isBaseHex()) {
            inputStr('6')
        }
    }
    fin()
    return false
}

function btn7() {
    if (isLeftShifted()) {
        // None
    } else if (isRightShifted()) {
        // None
    } else {
        if (isBaseOct() || isBaseDec() || isBaseHex()) {
            inputStr('7')
        }
    }
    fin()
    return false
}

function btn8() {
    if (isLeftShifted()) {
        // None
    } else if (isRightShifted()) {
        // None
    } else {
        if (isBaseDec() || isBaseHex()) {
            inputStr('8')
        }
    }
    fin()
    return false
}

function btn9() {
    if (isLeftShifted()) {
        // None
    } else if (isRightShifted()) {
        // None
    } else {
        if (isBaseDec() || isBaseHex()) {
            inputStr('9')
        }
    }
    fin()
    return false
}

function btnAdd() {
    if (isLeftShifted()) {
        // None
    } else if (isRightShifted()) {
        // None
    } else {
        fn(add)
    }
    return false
}

function btnBase() {
    if (isLeftShifted()) {
        nextMode()
    } else if (isRightShifted()) {
        fn(bitwiseOr)
    } else {
        if (_isPending()) {
            enterKey()
        }
        nextBase()
    }
    fin()
    return false
}


function btnChangeSign() {
    if (isLeftShifted()) {
        rand()
    } else if (isRightShifted()) {
        fn(mod)
    } else {
        negate()
    }
    fin()
    return false
}

function btnC() {
    // Clear, regardless of left or right shift buttons.
    if (_isPending()) {
        _clearPending()
    }
    fin()
    return false
}

function btnCos() {
    if (isLeftShifted()) {
        fn(arccos)
    } else if (isRightShifted()) {
        // None
    } else {
        fn(cos)
    }
    fin()
    return false
}

function btnDeleteChar() {
    if (isLeftShifted()) {
        // None
    } else if (isRightShifted()) {
        _saveStack()
        _clearPending()
        _clearStack()
        _clearStored()
    } else {
        if (_isPending()) {
            PENDING = PENDING.substring(0, PENDING.length-1)
        } else {
            fn(drop)
        }
    }
    fin()
    return false
}

function btnDot() {
    if (isBaseDec()) {
        if (isLeftShifted()) {
            inputTau()
        } else if (isRightShifted()) {
            inputPi()
        } else {
            inputStr('.')
        }
    }
    fin()
    return false
}

function btnDisp() {
    if (isLeftShifted()) {
        // None
    } else if (isRightShifted()) {
        fn(bitwiseNot)
    } else {
        if (_isPending() && isPrecisionFix() && isBaseDec() && _isInt(PENDING)) {
            const p = parseInt(PENDING)
            if (p >= 0) {
                DISP_PREC = Math.min(p, MAX_PRECISION)
                _clearPending()
            } else {
                nextPrecision()
            }
        } else {
            nextPrecision()
        }
        _updateLcd()
    }
    fin()
    return false
}

function btnDivide() {
    if (isLeftShifted()) {
        // None
    } else if (isRightShifted()) {
        // None
    } else {
        fn(divide)
    }
    fin()
    return false
}

function btnEnter() {
    if (isLeftShifted()) {
        // None
    } else if (isRightShifted()) {
        // None
    } else {
        _stopBlinking()
        enterKey()
    }
    fin()
    return false
}

function btnExpo() {
    if (isLeftShifted()) {
        fn(combination)
    } else if (isRightShifted()) {
        fn(factorial)
    } else {
        // inputStr('E')
        inputStr(EXPO_CHR)
    }
    fin()
    return false
}

function btnFactorial() {
    fn(factorial)
    fin()
    return false
}

function btnLeftShift() {
    if (isLeftShifted()) {
        leftShiftOff()
    } else {
        leftShiftOn()
    }
    rightShiftOff()
    _updateLcd()
    return false
}

function btnMultiply() {
    if (isLeftShifted()) {
        // None
    } else if (isRightShifted()) {
        // None
    } else {
        fn(multiply)
    }
    fin()
    return false
}

function btnPowyx() {
    if (isLeftShifted()) {
        fn(pow10x)
    } else if (isRightShifted()) {
        fn(logx)
    } else {
        fn(powyx)
    }
    fin()
    return false
}

function btnRecip() {
    if (isLeftShifted()) {
        fn(powex)
    } else if (isRightShifted()) {
        fn(lnx)
    } else {
        fn(reciprocal)
    }
    fin()
    return false
}

function btnRightShift() {
    if (isRightShifted()) {
        rightShiftOff()
    } else {
        rightShiftOn()
    }
    leftShiftOff()
    _updateLcd()
    return false
}


function btnSto() {
    if (isLeftShifted()) {
        recallx()
        _saveStack()
    } else if (isRightShifted()) {
        fn(bitwiseAnd)
    } else {
        storex()
    }
    fin()
    return false
}

function btnSin() {
    if (isLeftShifted()) {
        fn(arcsin)
    } else if (isRightShifted()) {
        // None
    } else {
        fn(sin)
    }
    fin()
    return false
}

function btnSqrt() {
    if (isLeftShifted()) {
        fn(rootxy)
    } else if (isRightShifted()) {
        fn(bitwiseXor)
    } else {
        fn(sqrt)
    }
    fin()
    return false
}


function btnSubtract() {
    if (isLeftShifted()) {
        // None
    } else if (isRightShifted()) {
        // None
    } else {
        fn(subtract)
    }
    fin()
    return false
}


function btnSwap() {
    if (isLeftShifted()) {
        // None
    } else if (isRightShifted()) {
        undoPrevOp()
    } else {
        fn(swapxy)
    }
    fin()
    return false
}

function btnTan() {
    if (isLeftShifted()) {
        fn(arctan)
    } else if (isRightShifted()) {
        // None
    } else {
        fn(tan)
    }
    fin()
    return false
}





// #############################################################
// ###### OTHER
// #############################################################

// Euler's gamma function for computing factorial of non-integers. 
// e.g. 0.5! = sqrt(pi) / 2
// https://stackoverflow.com/questions/15454183/how-to-make-a-function-that-computes-the-factorial-for-numbers-with-decimals
// Claims to be accurate to 15 decimal places.
function _gamma(val) {
    var g = 7
    var C = [
        0.99999999999980993,
        676.5203681218851,
        -1259.1392167224028,
        771.32342877765313,
        -176.61502916214059,
        12.507343278686905,
        -0.13857109526572012,
        9.9843695780195716e-6,
        1.5056327351493116e-7
    ]

    function gamma(z) {

        if (z < 0.5) {
            return Math.PI / (Math.sin(Math.PI * z) * gamma(1 - z));
        } else {
            z -= 1;

            var x = C[0];
            for (var i = 1; i < g + 2; i++) {
                x += C[i] / (z + i)
            }
            var t = z + g + 0.5;
            return Math.sqrt(2 * Math.PI) * Math.pow(t, (z + 0.5)) * Math.exp(-t) * x;
        }
    }
    return gamma(val)
}


function _gammaFact(val) {
    if (Math.abs(val - 0) < Number.EPSILON ) { // zero
        return 1
    } else if (_isInt(val) && val > 0) { // positive integer
        return _fact(val)
    } else if (_isInt(val) && val < 0) { // negative integer
        // Gamma is not defined for negative integers because they are
        // discontinuous and result in +/- Infinity.
        console.log('gamma not defined for negative integers')
        return Infinity
    } else { // negative or positive non-integer
        return _gamma(val+1)
    }
}

function _fact(n) {
    var val=1
    for (var i = 2; i<=n; i++) {
        val *= i
    }
    return val
}



function _saveStack() {
    SAVED_STACK=[]
    for(var i=0; i<STACK.length; i++) {
        SAVED_STACK.push(STACK[i])
    }
}

function _drop(n) {
    const limit = (n ? n : 1)
    for (var i=0; i<limit; i++) {
        STACK.shift()
    }
}



function nextMode() {
    MODE = (MODE + 1) % Object.keys(MODES).length
    if (isModeDegrees()) {
        MODE_CONV = Math.PI / 180.0
    } else {
        MODE_CONV = 1.0
    }
}

function _enableBaseKeys() {
    // Start with (almost) all keys hidden, then progressively unhide keys.
    // This prevents 'blinking' the keys on slower machines when changing bases.
    if (BASE == BASES.BIN) {
        document.querySelectorAll('.oct').forEach(el => el.style.display = 'none')
        document.querySelectorAll('.dec').forEach(el => el.style.display = 'none')
        document.querySelectorAll('.hex').forEach(el => el.style.display = 'none')
    }

    if (BASE == BASES.OCT) {
        document.querySelectorAll('.oct').forEach(el => el.style.display = 'block')
    }

    if (BASE == BASES.DEC) {
        document.querySelectorAll('.dec').forEach(el => el.style.display = 'block')
    }

    if (BASE == BASES.HEX) {
        document.querySelectorAll('.dot').forEach(el => el.style.display = 'none')
        document.querySelectorAll('.hex').forEach(el => el.style.display = 'block')
    }
}

function nextBase() {
    BASE = (BASE + 1) % Object.keys(BASES).length
    _enableBaseKeys()
}

function nextPrecision() {
    PRECISION = (PRECISION + 1) % Object.keys(PREC).length
}

function fn(func) {
    _applyPending()
    _saveStack()
    func()
    leftShiftOff()
    rightShiftOff()
    _updateLcd()
}


function _has(n) {
    return STACK.length >= n
}

function _applyPending() {
    if (PENDING) {
        enterKey()
    }
}

function leftShiftOff() {
    IS_LEFT_SHIFTED = false
}

function rightShiftOff() {
    IS_RIGHT_SHIFTED = false
}

function leftShiftOn() {
    IS_LEFT_SHIFTED = true
}

function rightShiftOn() {
    IS_RIGHT_SHIFTED = true
}


function isLeftShifted() {
    return IS_LEFT_SHIFTED
}

function isRightShifted() {
    return IS_RIGHT_SHIFTED
}

function isBaseBin() {
    return BASE == BASES.BIN
}

function isBaseDec() {
    return BASE == BASES.DEC
}

function isBaseHex() {
    return BASE == BASES.HEX
}

function isBaseOct() {
    return BASE == BASES.OCT
}

function isModeDegrees() {
    return MODE == MODES.DEG
}

function isModeRadians() {
    return MODE == MODES.RAD
}

function isPrecisionFix() {
    return PRECISION == PREC.FIX
}

function isPrecisionSci() {
    return PRECISION == PREC.SCI
}

function isPrecisionAll() {
    return PRECISION == PREC.ALL
}

function isStored() {
    return STORED_X != null
}

function _isPending() {
    return PENDING != ''
}

function _isInt(str) {
    const i = parseInt(str)
    return ''+i == str
}

function _clearPending() {
    PENDING = ''
}

function _clearStack() {
    STACK = []
}

function _clearStored() {
    STORED_X = null
}

function toFix(val, dispPrec) {
    const num = (typeof val === 'number' ? val : Number(val))
    return (num ? ''+num.toFixed(dispPrec) : '')
}

function toSci(val, dispPrec) {
    const num = (typeof val === 'number' ? val : Number(val))
    return (num ? ''+num.toExponential(dispPrec) : '')
}


// Javascript bitwise operators can only operate on (signed) 32-bit values.
// Larger values will be truncated to fit in 32-bits.
// The leftmost bit is used to store the sign. As a consequence,
// bitwise operators can operate on values from -2^31 to 2^31-1.
function toBinary(val) {
     // NOT (2^32-1) returns '0', rather than many zeros. 
     const isNeg = (val < 0)
     var intPart = parseInt(val)
     var str = ''
     if (isNeg) {
         let binstr = Math.abs(intPart+1).toString(2)
         str = binstr.replace(/0/g, 'z').replace(/1/g, '0').replace(/z/g, '1')
     } else {
         str = intPart.toString(2)
     }

     // Binary values are displayed in multiples of eight characters. To avoid
     // having to print 32 bits of a number, we print the shortest multiple of
     // eight characters that can hold the value. e.g. A value of '2' is shown
     // as 0b00000010 rather than 0b00000000_00000000_00000000_00000010.
     const pfx = (isNeg ? '1' : '0')
     while (str.length % 8) {
         str = pfx + str
     }
     // Some operations result in a string of all zeros. E.g. 'NOT 255'
     // (equivalent to 'NOT -256') will result in 0b00000000, which
     // can be interpreted as 0b11111111_00000000 or 0b00000000_00000000.
     // To disambiguate this, 0b11111111 will be prepended to negative values.
     if (isNeg) {
          str = '1'.repeat(8) + str
     }

     return '0b'+str.match(/.{8}/g).join('_')
}

function toAll(val) {
    if (typeof val === 'undefined') {
      return ''
    }

    var intPart = parseInt(val);
    var isNeg = intPart < 0
    var absVal = Math.abs(intPart)
    if (isBaseBin()) {
        return toBinary(val)
    }
    if (isBaseOct()) {
        let octStr = '0o'+Math.abs(intPart).toString(8)
        if (intPart < 0) {
            octStr = '-'+octStr
        }
        return octStr
    }
    if (isBaseHex()) {
        let hexStr = '0x'+Math.abs(intPart).toString(16).toUpperCase()
        if (intPart < 0) {
            hexStr = '-'+hexStr
        }
        return hexStr
    }
    return Math.round(parseFloat(val) * ROUND_LIM) / ROUND_LIM
}

function _fmt(val) {
    if (isBaseDec()) {
        if (isPrecisionFix()){
            return toFix(val, DISP_PREC)
        } else if (isPrecisionSci()) {
            return toSci(val, DISP_PREC)
        }
    }
    return toAll(val)
}

function _updateLcd() {

    // These arrows are supported/visible in all browsers; others may not be.
    // Curved arrows (e.g. U2937) look nice, but require rotation.
    const upwardLeftArrow = '\u21b0'
    const upwardRightArrow = '\u21b1'

    const lsEle = document.getElementById('lsind')
    lsEle.innerHTML = (isLeftShifted() ? upwardLeftArrow : '')

    const rsEle = document.getElementById('rsind')
    rsEle.innerHTML = (isRightShifted() ? upwardRightArrow : '')

    const modeEle = document.getElementById('modeind')
    modeEle.innerHTML = (isModeRadians() ? 'RAD' : 'DEG')

    const precEle = document.getElementById('precind')
    precEle.innerHTML = (isPrecisionFix() ? 'FIX' : (isPrecisionSci() ? 'SCI' : 'ALL')) 

    // 'DEC' for decimal and 'DEG' for degrees are almost indistinguishable,
    // so use numbers rather than three-letter abbreviations for base.
    const baseEle = document.getElementById('baseind')
    baseEle.innerHTML = (isBaseHex() ? '16' : isBaseDec() ? '10' : isBaseOct() ? ' 8' : ' 2')

    // Truncate if too large to prevent altering positions of other indicators.
    const ellipsis = '&hellip;'
    const maxLen = 9
    let storedStr = '' + STORED_X
    if (storedStr.length > maxLen) {
        storedStr = storedStr.substring(0, maxLen-1) + ellipsis
    }

    const stoEle = document.getElementById('stoind')
    stoEle.innerHTML = (isStored() ? 'S='+storedStr : '')

    const blinkOnChar = '\u25fb'
    const blinkOffChar = '\u25fc'

    let line3 = _fmt(STACK[3])
    let line2 = _fmt(STACK[2])
    let line1 = _fmt(STACK[1])
    let line0 = _fmt(STACK[0])
    if (PENDING) {
        line3 = line2
        line2 = line1
        line1 = line0
        line0 = PENDING + (BLINK_STATE ? blinkOnChar : blinkOffChar)
    }
    const el = document.getElementById('lcd')
    el.value = ['', line3, line2, line1, line0].join('\n')
}

function _startBlinking() {
    IS_BLINKING = true
    setTimeout(_continueBlinking, 1)
}

function _continueBlinking() {
    if (!_isBlinking()) {
        return
    }
    BLINK_STATE = !BLINK_STATE
    _updateLcd()
    setTimeout(_continueBlinking, BLINK_DELAY_MS)
}


function _stopBlinking() {
    IS_BLINKING = false
}

</script>

<style type="text/css">
body {
  padding: 0;
  margin: 0;
}

table.calculator {
    /* background-image: linear-gradient(#565c5c, #1a191e);  */
    xxbackground-image: linear-gradient(#565c5c, #1a191e);
    background-image: linear-gradient(#565c5c, #2a292e);
    xbackground-color: #1a191e; /* dark gray */
    width: 100vw;
    height: 100vh;
}
td {
    text-align: center;
}
#lcd {
    color: black;
    background-color: #d3e1c6; /* silver */
    display: black;
    font-family: monospace;
    font-size: xx-large;
    font-weight: bold;
    text-align: right;
    width: 95%;
    vertical-align: middle;
}
#lsind {
    color: black;
    flex: 0.5;
    font-weight: bolder;
    font-size: large;
}
#rsind {
    color: black;
    flex: 0.5;
    font-weight: bolder;
    font-size: large;
}
#annunce {
    display: flex;
    height: 1px;
    justify-content: space-around;
    width: 95%;
}
#stoind {
    text-align: left;
}
.hex {
    display: none;
}
.ind {
    flex: 1;
    font-family: monospace;
    font-size: small;
    position: relative;
    top: 5px;
    height: 1px;
    z-index: 20;
}

button#leftshiftbtn {
   xxxbackground: url('shift-left.svg') no-repeat center, linear-gradient(#948ac7, #625573);
   background: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0NSA1MCI+CjxwYXRoIGlkPSJBcnJvd0xlZnQiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMSIKZD0iTSAxLjIyLDIxLjkxCkMgMy45MCwxOS4yMyAxMS42NSwxMS40OCAxNC4wMCw5LjA0CjE3LjA5LDYuMDAgMjEuNjEsOS41MiAxOC42MSwxMy4xMwoxNC43OCwxNy4wNCAxNC42NCwxNy4zNCAxMy4wMCwxOS4wMAoxNy42NCwxOS4wMCAyOS44MywxOS4wMCAzNy4wOSwxOS4wNAo0MS44NywxOC45MSA0Mi4zNSwyMi4zNSA0Mi4xNywyNC4wNAo0Mi4wOSwyOC42NSA0Mi4xNywzNi40MCA0Mi4xNyw0MC45Ngo0Mi4xNyw0MC45NiAzNi4wMCw0MS4wMCAzNi4wMCw0MS4wMAozNi4wMCwzNy44OSAzNi4xMywzMi4zOSAzNi4wNCwyNy4wOQozNi4wOSwyNS4xMyAzNC45MSwyNS4wNCAzMy43NCwyNS4wNAoyOC4xMywyNS4wOSAxNy4xOSwyNS4wMCAxMy4wMCwyNS4wMAoxNC44OSwyNi45MCAxMy44MywyNi4wOSAxOC41MiwzMC44NwoyMi41MiwzNC4zMCAxNy42MSwzOC43NCAxNC4zMCwzNS4wNAoxMC4yNiwzMC44MyA2LjU3LDI3LjUyIDEuMjIsMjEuOTEgWiIgLz4KPC9zdmc+Cg==') no-repeat center, linear-gradient(#948ac7, #625573);
}

button#rightshiftbtn {
   xxxxbackground: url('shift-right.svg') no-repeat center, linear-gradient(#6bc6b5, #317c65);
   background: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0NSA1MCI+CjxwYXRoIGlkPSJTZWxlY3Rpb24iIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMSIKZD0iTSA0My43OCwyMS45MQpDIDQxLjEwLDE5LjIzIDMzLjM1LDExLjQ4IDMxLjAwLDkuMDQKMjcuOTEsNi4wMCAyMy4zOSw5LjUyIDI2LjM5LDEzLjEzCjMwLjIyLDE3LjA0IDMwLjM2LDE3LjM0IDMyLjAwLDE5LjAwCjI3LjM2LDE5LjAwIDE1LjE3LDE5LjAwIDcuOTEsMTkuMDQKMy4xMywxOC45MSAyLjY1LDIyLjM1IDIuODMsMjQuMDQKMi45MSwyOC42NSAyLjgzLDM2LjQwIDIuODMsNDAuOTYKMi44Myw0MC45NiA5LjAwLDQxLjAwIDkuMDAsNDEuMDAKOS4wMCwzNy44OSA4Ljg3LDMyLjM5IDguOTYsMjcuMDkKOC45MSwyNS4xMyAxMC4wOSwyNS4wNCAxMS4yNiwyNS4wNAoxNi44NywyNS4wOSAyNy44MSwyNS4wMCAzMi4wMCwyNS4wMAozMC4xMSwyNi45MCAzMS4xNywyNi4wOSAyNi40OCwzMC44NwoyMi40OCwzNC4zMCAyNy4zOSwzOC43NCAzMC43MCwzNS4wNAozNC43NCwzMC44MyAzOC40MywyNy41MiA0My43OCwyMS45MSBaIiAvPgo8L3N2Zz4K') no-repeat center, linear-gradient(#6bc6b5, #317c65);
}

button {
    background-image: linear-gradient(#242d34, #181914);
    border-color: gray;
    color: white;
    display: block;
    font-size: large;
    height: 97%;
    position: relative;
    width: 97%;
    margin: auto auto;
    border-radius: 7px;
}

td {
    width: 20%;
}
div.tdc.sz2 {
  font-size: xx-large;
}
div.tdc.sz1 {
  font-size: x-large;
}
div.tdc {
    font-weight: bold;
    font-size: large;
}
div.tdr {
    color: #79e5d5; /* teal */
    font-family: monospace;
    text-align: center;
    font-size: small;
    position: absolute;
    top: 0;
    right: 2px;
    font-weight: bold;
}
div.tdl {
    xcolor: #00ff00;
    font-weight: bold;

    color: #948ac7; /* lavendar */
    font-family: monospace;
    text-align: center;
    font-size: small;
    position: absolute;
    top: 0;
    left: 2px;
}
</style>

</head>
<body onload="init()">

      <div id="rpncal">
        <table class="calculator">
          <tbody>

          <tr>
            <td class="tdd" colspan="5">
              <center>
                <div id='annunce'>
                  <div id='lsind' class="ind"></div>
                  <div id='rsind' class="ind"></div>
                  <div id='baseind' class="ind"></div>
                  <div id='precind' class="ind"></div>
                  <div id='modeind' class="ind"></div>
                  <div id='stoind' class="ind"></div>
                </div>
                <textarea rows=5 id='lcd' spellcheck='false' wrap='off' readonly="readonly"></textarea>
              </center>
            </td>
          </tr>

           <tr>
            <td class="tds"><button onclick="return btnSto()"><div class='tdl'>RCL</div><div class='tdr'>AND</div><div class='tdc'>STO</div></button></td>
            <td class="tds"><button onclick="return btnDisp()"><div class='tdr'>NOT</div><div class='tdc'>DISP</div></button></td>
            <td class="tds"><button onclick="return btnBase()"><div class='tdl'>MODE</div><div class='tdr'>OR</div><div class='tdc shrink'>BASE</btuton></td>
            <td class="tds"><button onclick="return btnSqrt()"><div class='tdl'>x&radic;y</div><div class='tdr'>XOR</div><div class='tdc'>&radic;x</div></button></td>
            <td class="tds"><button onclick="return btnSwap()"><div class='tdr'>UNDO</div><div class='tdc'>SWAP</div></button></td>
          </tr>

          <tr>
            <td class="tds"><button onclick="return btnSin()"><div class='tdl'>ASIN</div><div class='tdc'>SIN</div></button></td>
            <td class="tds"><button onclick="return btnCos()"><div class='tdl'>ACOS</div><div class='tdc'>COS</div></btuton></td>
            <td class="tds"><button onclick="return btnTan()"><div class='tdl'>ATAN</div><div class='tdc'>TAN</div></btuton></td>
            <td class="tds"><button onclick="return btnRecip()"><div class='tdl'>e<sup>x</sup></div><div class='tdr'>LN</div><div class='tdc'>1/x</div></button></td>
            <td class="tds"><button onclick="return btnPowyx()"><div class='tdl'>10<sup>x</sup></div><div class='tdr'>LOG</div><div class='tdc'>y<sup>x</sup></div></button></td>
           </tr>

          <tr>
            <td class="tds" colspan="2"><button onclick="return btnEnter()"><div class='tdc'>ENTER</div></button></td>
            <td class="tds"><button onclick="return btnChangeSign()"><div class='tdl'>RAND</div><div class='tdr'>MOD</div><div class='tdc sz1'>+/-</div></button></td>
            <td class="tds"><button onclick="return btnExpo()"><div class='tdl'>C(y,x)</div><div class='tdr'>x!</div><div class='tdc'>EEX</div></button></td>
            <td class="tds"><button onclick="return btnDeleteChar()"><div class='tdr'>CLEAR</div><div class='tdc sz2'>&DoubleLeftArrow;</div></button></td>
          </tr>

          <tr>
            <td class="tds">&nbsp;</td>
            <td class="tds"><button onclick="return btn7()"><div class='tdc oct sz2'>7</div></button></td>
            <td class="tds"><button onclick="return btn8()"><div class='tdc dec sz2'>8</div></button></td>
            <td class="tds"><button onclick="return btn9()"><div class='tdc dec sz2'>9</div></button></td>
            <td class="tds"><button onclick="return btnDivide()"><div class='tdc sz2'>&div;</div></button></td>
          </tr>

          <tr>
  	        <td class="tds"><button id="leftshiftbtn" onclick="return btnLeftShift()">&nbsp;</button></td>
            <td class="tds"><button onclick="return btn4()"><div class='tdr hex'>E</div><div class='tdc oct sz2'>4</div></button></td>
            <td class="tds"><button onclick="return btn5()"><div class='tdr hex'>F</div><div class='tdc oct sz2'>5</div></button></td>
            <td class="tds"><button onclick="return btn6()"><div class='tdc oct sz2'>6</div></button></td>
            <td class="tds"><button onclick="return btnMultiply()"><div class='tdc sz2'>&times;</div></button></td>
          </tr>

          <tr>
  	        <td class="tds"><button id="rightshiftbtn" onclick="return btnRightShift()">&nbsp;</button></td>
            <td class="tds"><button onclick="return btn1()"><div class='tdr hex'>B</div><div class='tdc sz2'>1</div></button></td>
            <td class="tds"><button onclick="return btn2()"><div class='tdr hex'>C</div><div class='tdc oct sz2'>2</div></button></td>
            <td class="tds"><button onclick="return btn3()"><div class='tdr hex'>D</div><div class='tdc oct sz2'>3</div></button></td>
            <td class="tds"><button onclick="return btnSubtract()"><div class='tdc sz2'>&minus;</div></button></td>
          </tr>

          <tr>
            <td class="tds"><button onclick="return btnC()"><div class='tdc sz2'>C</div></button></td>
            <td class="tds"><button onclick="return btn0()"><div class='tdr hex'>A</div><div class='tdc sz2'>0</div></button></td>
            <td class="tds"><button onclick="return btnDot()"><div class='tdl dec dot'>&tau;</div><div class='tdr dec dot'>&pi;</div><div class='tdc dec sz2 dot'>.</div></button></td>
  	        <td class="tds">&nbsp;</td>
            <td class="tds"><button onclick="return btnAdd()"><div class='tdc sz2'>+</div></button></td>
          </tr>

         </tbody>
       </table>

      </div>

</body>
</html>
